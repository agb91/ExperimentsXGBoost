from  __future__ import division
from gene import Gene
from geneCreator import GeneCreator
from titanic_boost_regressor import TitanicBoostRegressor
from titanic_boost_classifier import TitanicBoostClassifier
import numpy as np
import random
import math
from dataReader import DataReader
from various_forests import VariousForests


class Breeder:

	def getNewGeneration( self, old, n):
		geneCreator = GeneCreator()
		newGeneration = list()
		strongestN = 3
		if(n<3):
			strongestN = n
		reprods = math.ceil(n/2.5)
		randomAdds = 2 
		goods = self.takeGoods( old , strongestN )
		reproducible = self.takeGoods(old, reprods )
		#I want to maintain old goods in my genetic pools
		for i in range( 0, len(goods) ):
			newGeneration.append(goods[i])
		#I want some sons generated by goods
		for i in range( 0 , (n - strongestN - randomAdds ) ):
			son = self.getSon( reproducible )
			newGeneration.append(son)
		#I want also some randoms new borns
		for i in range( 0, randomAdds ):
			newGeneration.append( geneCreator.randomCreate() )
		
		return newGeneration

	def getSon( self, parents ):


		cbti = random.randint(0, (len(parents) - 1 ) )
		cbt = parents[cbti].col_by_tree 
		
		ssi = random.randint(0, (len(parents) - 1 ))
		ss = parents[ssi].subsample 

		mcwi = random.randint(0, (len(parents) - 1 ))
		mcw = parents[mcwi].min_child_weight 

		mdi = random.randint(0, (len(parents) - 1 ))
		md = parents[mdi].max_depth 

		nei  = random.randint(0, (len(parents) - 1 ))
		ne = parents[nei].n_estimators 

		lri = random.randint(0, (len(parents) - 1 ))
		lr = parents[lri].learning_rate 

		wayi = random.randint(0, (len(parents) - 1 ))
		way = parents[wayi].way

		nnei = random.randint( 0, (len(parents) - 1 ))
		n_neighbors = parents[nnei].way

		son = Gene( cbt, ss, mcw, md, ne, lr, way , n_neighbors)
		
		return son	

	def run(self, generation):
		runnedGeneration = list()
		dataReader = DataReader()
		X,Y,X_test,X_output = dataReader.readData()

		
		for i in range( 0 , len(generation)):
			
			thisGene = generation[i]
			runner = TitanicBoostClassifier()	#just to initialize...
			if( thisGene.way == 0 ):
				runner = TitanicBoostClassifier()
			else:
				if( thisGene.way == 1 ):
					runner = TitanicBoostRegressor()
				else:
					runner = VariousForests()	

			runner.setDatasets( X , Y , X_test , X_output )
			runner.set_gene_to_model( thisGene )
			thisGene.setFitnessLevel( runner.run() ) 
			runnedGeneration.append(thisGene)

		return runnedGeneration	

	def getFirstGeneration( self, n ):
		genes = list()
		creator = GeneCreator()
		for i in range( 0 , n):
			g = creator.randomCreate()
			genes.append(g)
		return genes

	def orderGenes( self , genes ):
		result = []
		genesSet = set(genes)
		genes = list( genesSet ) # no doubles!
		#for i in range( 0, len(genes) ):
		#	print( "before: " + str(genes[i].level) )		
		
		result = sorted(genes, key=lambda x: x.level, reverse=True)
		#for i in range( 0, len(result) ):
		#	print( result[i].level )		
		
		return result

	def takeGoods( self, genes, n ):
		goods = []

		for i in range(0, len(genes) ):
			g = genes[i]
			goods.append(g)
			goods = self.orderGenes( goods )
			if( len( goods ) > n):
				goods = goods[ 0 : n ]

		#for i in range( 0, len(goods) ):
		#	print( goods[i].level )		
		return goods		    

	def takeBest( self, genes ):

		maxLevel = 0 #level of correctness percentage
		bestGene = None

		for i in range(0, len(genes) ):
			g = genes[i]
			if( g.level > maxLevel ):
				bestGene = g
				maxLevel = g.level

		return bestGene		