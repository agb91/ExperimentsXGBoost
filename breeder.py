from  __future__ import division
from gene import Gene
from gene_creator import GeneCreator
from titanic_boost_regressor import TitanicBoostRegressor
from titanic_boost_classifier import TitanicBoostClassifier
import numpy as np
import random
import math
from data_reader import DataReader
from various_forests import VariousForests


class Breeder:

	def get_new_generation( self, old, n):
		gene_creator = GeneCreator()
		new_generation = list()
		strongest_n = 3
		if(n<3):
			strongest_n = n
		reprods = math.ceil(n/2.5)
		random_adds = 2 
		goods = self.take_goods( old , strongest_n )
		reproducible = self.take_goods(old, reprods )
		#I want to maintain old goods in my genetic pools
		for i in range( 0, len(goods) ):
			new_generation.append(goods[i])
		#I want some sons generated by goods
		for i in range( 0 , (n - strongest_n - random_adds ) ):
			son = self.get_son( reproducible )
			new_generation.append(son)
		#I want also some randoms new borns
		for i in range( 0, random_adds ):
			new_generation.append( gene_creator.random_create() )
		
		return new_generation

	def get_son( self, parents ):


		cbti = random.randint(0, (len(parents) - 1 ) )
		cbt = parents[cbti].col_by_tree 
		
		ssi = random.randint(0, (len(parents) - 1 ))
		ss = parents[ssi].subsample 

		mcwi = random.randint(0, (len(parents) - 1 ))
		mcw = parents[mcwi].min_child_weight 

		mdi = random.randint(0, (len(parents) - 1 ))
		md = parents[mdi].max_depth 

		nei  = random.randint(0, (len(parents) - 1 ))
		ne = parents[nei].n_estimators 

		lri = random.randint(0, (len(parents) - 1 ))
		lr = parents[lri].learning_rate 

		wayi = random.randint(0, (len(parents) - 1 ))
		way = parents[wayi].way

		nnei = random.randint( 0, (len(parents) - 1 ))
		n_neighbors = parents[nnei].way

		son = Gene( cbt, ss, mcw, md, ne, lr, way , n_neighbors)
		
		return son	

	def run(self, generation):
		runned_generation = list()
		data_reader = DataReader()
		X,Y,X_test,X_output = data_reader.read_data()

		
		for i in range( 0 , len(generation)):
			
			this_gene = generation[i]
			runner = TitanicBoostClassifier()	#just to initialize...
			if( this_gene.way == 0 ):
				runner = TitanicBoostClassifier()
			else:
				if( this_gene.way == 1 ):
					runner = TitanicBoostRegressor()
				else:
					runner = VariousForests()	

			runner.set_datasets( X , Y , X_test , X_output )
			runner.set_gene_to_model( this_gene )
			this_gene.set_fitness_level( runner.run() ) 
			runned_generation.append(this_gene)

		return runned_generation	

	def get_first_generation( self, n ):
		genes = list()
		creator = GeneCreator()
		for i in range( 0 , n):
			g = creator.random_create()
			genes.append(g)
		return genes

	def order_genes( self , genes ):
		result = []
		genes_set = set(genes)
		genes = list( genes_set ) # no doubles!
		#for i in range( 0, len(genes) ):
		#	print( "before: " + str(genes[i].level) )		
		
		result = sorted(genes, key=lambda x: x.level, reverse=True)
		#for i in range( 0, len(result) ):
		#	print( result[i].level )		
		
		return result

	def take_goods( self, genes, n ):
		goods = []

		for i in range(0, len(genes) ):
			g = genes[i]
			goods.append(g)
			goods = self.order_genes( goods )
			if( len( goods ) > n):
				goods = goods[ 0 : n ]

		#for i in range( 0, len(goods) ):
		#	print( goods[i].level )		
		return goods		    

	def take_best( self, genes ):

		max_level = 0 #level of correctness percentage
		best_gene = None

		for i in range(0, len(genes) ):
			g = genes[i]
			if( g.level > max_level ):
				best_gene = g
				max_level = g.level

		return best_gene		